[
  {
    "timestamp": "2025-12-28T23:18:11.357Z",
    "file": "/Users/swarit-dev/voight/src/detection/complexity/functionBoundaryDetector.ts",
    "detected": true,
    "textLength": 715,
    "completeText": "        console.log('[BoundaryDetector] Detecting boundaries for functions:', functions.map(f => f.name));\n\n        for (const func of functions) {\n            const boundary = this.findFunctionBoundary(lines, func.name, language);\n            if (boundary) {\n                console.log(`[BoundaryDetector] Found boundary for \"${func.name}\": lines ${boundary.startLine}-${boundary.endLine}`);\n                boundaries.push(boundary);\n            } else {\n                console.warn(`[BoundaryDetector] Could not find boundary for function: ${func.name}`);\n            }\n        }\n\n        console.log('[BoundaryDetector] Final boundaries order:', boundaries.map(b => `${b.name}:${b.startLine}-${b.endLine}`));\n",
    "rangeStart": {
      "line": 27,
      "char": 0
    },
    "rangeEnd": {
      "line": 34,
      "char": 0
    },
    "rangeIsEmpty": false,
    "timeSinceLastChange": 1766963891357,
    "documentVersion": 2
  },
  {
    "timestamp": "2025-12-28T23:22:47.476Z",
    "file": "/Users/swarit-dev/voight/src/detection/changeDetector.ts",
    "detected": true,
    "textLength": 858,
    "completeText": "        // Debug logging for function-boundary pairing\n        Logger.debug(`[Function Splitting] Functions detected: ${functions.map(f => f.name).join(', ')}`);\n        Logger.debug(`[Function Splitting] Boundaries found: ${boundaries.map(b => `${b.name}:${b.startLine}-${b.endLine}`).join(', ')}`);\n\n        // Use detected boundaries or fall back to simple distribution\n        for (let i = 0; i < functions.length; i++) {\n            const func = functions[i];\n            const boundary = boundaries[i];\n\n            Logger.debug(`[Function Splitting] Processing index ${i}: function=\"${func.name}\", boundary=\"${boundary?.name || 'null'}\"`);\n\n            if (boundary && boundary.name !== func.name) {\n                Logger.warn(`[Function Splitting] ⚠️  MISMATCH at index ${i}: function=\"${func.name}\" but boundary=\"${boundary.name}\"`);\n            }\n",
    "rangeStart": {
      "line": 350,
      "char": 0
    },
    "rangeEnd": {
      "line": 354,
      "char": 0
    },
    "rangeIsEmpty": false,
    "timeSinceLastChange": 276119,
    "documentVersion": 2
  },
  {
    "timestamp": "2025-12-28T23:30:29.652Z",
    "file": "/Users/swarit-dev/voight/src/ui/segmentsWebviewProvider.ts",
    "detected": true,
    "textLength": 89,
    "completeText": "    private _lastViewedFilePath?: string; // Persist which file's segments we're showing\n",
    "rangeStart": {
      "line": 15,
      "char": 0
    },
    "rangeEnd": {
      "line": 15,
      "char": 0
    },
    "rangeIsEmpty": true,
    "timeSinceLastChange": 462176,
    "documentVersion": 2
  },
  {
    "timestamp": "2025-12-28T23:31:01.005Z",
    "file": "/Users/swarit-dev/voight/src/ui/segmentsWebviewProvider.ts",
    "detected": true,
    "textLength": 3381,
    "completeText": "        const blocks = this._blockManager.getAllBlocks();\n        Logger.debug(`[SegmentsWebviewProvider] Active file: ${activeFilePath || 'none'}`);\n        Logger.debug(`[SegmentsWebviewProvider] Last viewed file: ${this._lastViewedFilePath || 'none'}`);\n        Logger.debug(`[SegmentsWebviewProvider] Total blocks: ${blocks.length}`);\n\n        // Log all block file paths for debugging\n        blocks.forEach(b => {\n            Logger.debug(`  Block ${b.id}: ${b.filePath} (lines ${b.startLine}-${b.endLine})`);\n        });\n\n        // Determine which file to show segments for\n        let fileToShow: string | undefined;\n\n        if (activeFilePath) {\n            // Check if active file has any segments\n            const activeFileHasSegments = blocks.some(block => block.filePath === activeFilePath);\n\n            if (activeFileHasSegments) {\n                // Active file has segments, switch to it\n                fileToShow = activeFilePath;\n                this._lastViewedFilePath = activeFilePath;\n                Logger.debug(`[SegmentsWebviewProvider] Active file has segments, switching to it`);\n            } else {\n                // Active file has no segments, keep showing last viewed file\n                fileToShow = this._lastViewedFilePath;\n                Logger.debug(`[SegmentsWebviewProvider] Active file has no segments, keeping last viewed file`);\n            }\n        } else {\n            // No active file, keep showing last viewed file\n            fileToShow = this._lastViewedFilePath;\n            Logger.debug(`[SegmentsWebviewProvider] No active file, keeping last viewed file`);\n        }\n\n        // If we don't have a file to show, show file list or empty state\n        if (!fileToShow) {\n            Logger.debug('[SegmentsWebviewProvider] No file to show segments for');\n\n            if (blocks.length > 0) {\n                // Show file list\n                this._showFileList(blocks);\n            } else {\n                // Show empty state\n                this._view.webview.postMessage({\n                    command: 'updateSegments',\n                    segments: []\n                });\n            }\n            return;\n        }\n\n        // Filter: Show all segments from the file we're displaying, except reviewed/dismissed ones\n        // Exception: Always show starred or segments with context notes\n        const filteredBlocks = blocks.filter((block: HighlightSegment) => {\n            // Only show segments from the file we're displaying\n            if (block.filePath !== fileToShow) {\n                return false;\n            }\n\n            // Check if segment is reviewed or dismissed\n            const isReviewedOrDismissed = block.state === SegmentState.REVIEWED || block.state === SegmentState.DISMISSED;\n\n            // Always show if starred or has context (even if reviewed/dismissed)\n            const hasContext = block.metadata?.context && block.metadata.context.trim().length > 0;\n            const isStarred = block.metadata?.isStarred === true;\n\n            if (isReviewedOrDismissed && !hasContext && !isStarred) {\n                return false;\n            }\n\n            return true;\n        });\n\n        Logger.debug(`[SegmentsWebviewProvider] Showing ${filteredBlocks.length} segments from ${fileToShow}`);\n\n        // If the file we're showing has no segments (all reviewed/dismissed), show file list\n",
    "rangeStart": {
      "line": 323,
      "char": 0
    },
    "rangeEnd": {
      "line": 369,
      "char": 0
    },
    "rangeIsEmpty": false,
    "timeSinceLastChange": 31353,
    "documentVersion": 3
  },
  {
    "timestamp": "2025-12-28T23:31:53.914Z",
    "file": "/Users/swarit-dev/voight/src/ui/segmentsWebviewProvider.ts",
    "detected": true,
    "textLength": 1188,
    "completeText": "     * Show file list view when no segments are available for current context\n     */\n    private _showFileList(blocks: HighlightSegment[]) {\n        if (!this._view) {\n            return;\n        }\n\n        // Group blocks by file and count segments\n        const fileMap = new Map<string, { count: number; blocks: HighlightSegment[] }>();\n\n        blocks.forEach(block => {\n            if (!fileMap.has(block.filePath)) {\n                fileMap.set(block.filePath, { count: 0, blocks: [] });\n            }\n            const entry = fileMap.get(block.filePath)!;\n            entry.count++;\n            entry.blocks.push(block);\n        });\n\n        // Transform to file list format\n        const fileList = Array.from(fileMap.entries()).map(([filePath, data]) => ({\n            filePath,\n            fileName: this._getFileName(filePath),\n            segmentCount: data.count,\n            previewName: this._getSegmentName(data.blocks[0])\n        }));\n\n        Logger.debug(`[SegmentsWebviewProvider] Showing file list with ${fileList.length} files`);\n\n        this._view.webview.postMessage({\n            command: 'showFileList',\n            files: fileList\n        });\n    }\n\n    /**\n",
    "rangeStart": {
      "line": 311,
      "char": 0
    },
    "rangeEnd": {
      "line": 311,
      "char": 0
    },
    "rangeIsEmpty": true,
    "timeSinceLastChange": 52909,
    "documentVersion": 4
  },
  {
    "timestamp": "2025-12-28T23:32:11.899Z",
    "file": "/Users/swarit-dev/voight/src/ui/segmentsWebviewProvider.ts",
    "detected": true,
    "textLength": 814,
    "completeText": "            this._showFileList(blocks);\n            return;\n        }\n\n        // Build file list for selector - group all blocks by file\n        const fileMap = new Map<string, { count: number; blocks: HighlightSegment[] }>();\n        blocks.forEach(block => {\n            if (!fileMap.has(block.filePath)) {\n                fileMap.set(block.filePath, { count: 0, blocks: [] });\n            }\n            const entry = fileMap.get(block.filePath)!;\n            entry.count++;\n            entry.blocks.push(block);\n        });\n\n        const allFiles = Array.from(fileMap.entries()).map(([filePath, data]) => ({\n            filePath,\n            fileName: this._getFileName(filePath),\n            segmentCount: data.count,\n            isActive: filePath === fileToShow // Use fileToShow instead of activeFilePath\n",
    "rangeStart": {
      "line": 435,
      "char": 0
    },
    "rangeEnd": {
      "line": 481,
      "char": 0
    },
    "rangeIsEmpty": false,
    "timeSinceLastChange": 17985,
    "documentVersion": 5
  },
  {
    "timestamp": "2025-12-28T23:32:42.870Z",
    "file": "/Users/swarit-dev/voight/src/ui/segmentsWebviewProvider.ts",
    "detected": true,
    "textLength": 149,
    "completeText": "                        // Set this as the last viewed file so segments persist\n                        this._lastViewedFilePath = message.filePath;\n",
    "rangeStart": {
      "line": 171,
      "char": 0
    },
    "rangeEnd": {
      "line": 171,
      "char": 0
    },
    "rangeIsEmpty": true,
    "timeSinceLastChange": 30971,
    "documentVersion": 6
  }
]